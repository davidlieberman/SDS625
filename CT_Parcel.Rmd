---
title: "CT Parcel Geospatial Data"
author: "David Lieberman"
output:
html_notebook: default
---


```{r setup, include=FALSE}
library(sf)
library(tigris)
library(reticulate)
library(ggplot2)
library(plotly)

here::i_am(".git/config")
knitr::opts_chunk$set("root.dir" = here::here("HW3"))
knitr::opts_chunk$set(eval = FALSE)

options(tigris_use_cache = TRUE)
options(tigris_year = 2023)
```

Read in the latest CT Real Estate data from the ArcGIS API where it is maintained
```{r}
dg <- st_read('https://services3.arcgis.com/3FL1kr7L4LvwA2Kb/arcgis/rest/services/Connecticut_State_Parcel_Layer_2023/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson')
# dg <- readRDS("dg.rds")

# Some minor corrections for broken geometries and dropping entries missing geometry
dg <- st_make_valid(dg) |> st_cast("MULTIPOLYGON")
dg <- dplyr::filter(dg, !st_is_empty(dg))
```

For complex geometries, it can be important to reduce the vertex count. Visvalingamâ€™s algorithm for decimating vertices
```{r}
# dg <- rmapshaper::ms_simplify(dg, keep = 0.001, keep_shapes = FALSE)
```


```{r}
CT <- filter_state(states(), state = "Connecticut") |> st_transform(crs = 4326)
dg_zip <- zctas(cb = TRUE, year = 2020, filter_by = CT, starts_with = "06") |> st_transform(crs = 4326)
st_bbox(CT) #-73.72777,40.95094,-71.78724,42.05051 
```

```{r}
# conda_install("overturemaps", forge = TRUE)
subprocess <- import("subprocess")
dg_water <- st_read(subprocess$check_output("overturemaps download --bbox=-73.72777,40.95094,-71.78724,42.05051 -f geojson -t water", stderr = subprocess$DEVNULL))

# dg_buildings <- st_read(subprocess$check_output("overturemaps download --bbox=-73.72777,40.95094,-71.78724,42.05051 -f geojson -t building", stderr = subprocess$DEVNULL))
```

```{r}
dg_waterfront <- st_intersection(subset(dg_water, subtype == "ocean"), CT) |> st_cast("MULTIPOLYGON") |> st_boundary()
dg_waterfront_buffer <- dg_waterfront |> st_transform(crs = 3488) |> st_buffer(dist = 25) |> st_transform(crs = 4326)
property_waterfront <- st_filter(dg, dg_waterfront_buffer, .predicate = st_within)

g <- ggplot() +
   geom_sf(data = dg_zip["geometry"]) +
   geom_sf(data = dg_waterfront["geometry"], color = "blue") +
   geom_sf(data = property_waterfront["geometry"], color = "red") +
   theme_bw()
p <- ggplotly(g)
htmlwidgets::saveWidget(toWebGL(p), "waterfront_houses_CT.html", selfcontained = TRUE)
```