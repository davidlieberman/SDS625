---
title: "9-25-2024 Methods"
author: "Lisa Lin"
date: "2024-09-25"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup, include=FALSE}
library(ggplot2)
library(plotly)
library(sf)
library(tigris)
library(data.table)
library(dplyr)
library(tidyr)

# here::i_am(".git/config")
# knitr::opts_chunk$set("root.dir" = here::here("HW3"))
# knitr::opts_chunk$set(eval = FALSE)
# knitr::opts_chunk$set(message = FALSE)
setDTthreads(threads = 0)

options(tigris_use_cache = TRUE)
options(tigris_year = 2021)
```

## Data Processing

```{r, eval = FALSE}
# Get crime data from ArcGIS API and remove (4) entries with missing geometry
# Write cleaned data to GeoJSON file
# crime_dg <- st_read("https://utility.arcgis.com/usrsvcs/servers/3adad6320b7a421bb3826ec8871e2b66/rest/services/OpenData_PublicSafety/MapServer/2/query?outFields=*&where=1%3D1&f=geojson")
# crime_dg$Date <- as.Date(fread(".//data//crime_dg.csv")$Date, "%Y/%m/%d")
# crime_dg <- crime_dg[!st_is_empty(crime_dg),]
# st_write(crime_dg, ".//data//crime_dg.geojson")

# Read in Hartford crime and parcel data
# c <- st_read(".//data//crime_dg.geojson")
# p <- st_read(".//data//parcel_hartford.geojson")

# Filter parcels for single family homes only
# Entire apartment or residential complexes are bought less frequently 
# and are more complicated to appraise.
# resid_labels <- c("ONE FAMILY") #, "TWO FAMILY", "THREE FAMILY")
# pr <- p[p$State_Use_Description %in% resid_labels, ]

# Filter crimes from 2016-2021
# Property appraisal was made in 2021.
# Assume that about 5 years of crime data is sufficient to capture the effect
# of crime on property values if any effect exists.
# cc <- c[as.Date(c$Date) >= as.Date("2016-01-01") & 
#           as.Date(c$Date) <= as.Date("2021-12-31"),]

# Save filtered data
# st_write(pr, ".//data//parcel_hartford_single_family.geojson")
# st_write(cc, ".//data//crime_hartford_2016_2021.geojson")
```

```{r}
# Read in filtered Hartford crime, parcel, and population data
c <- st_read(".//data//crime_hartford_2016_2021.geojson")
p <- st_read(".//data//parcel_hartford_single_family.geojson")
pop <- read.csv(".//data//population_by_tract.csv", skip = 3, header = T)[,1:3]

# Get polygons for Hartford's census tracts
hartford_tracts <- st_filter(tracts(state = "CT"),
                             subset(county_subdivisions(state = "CT"), 
                                    NAMELSAD == "Hartford town"),
                             .predicate = st_within) |>
   st_transform(crs = st_crs(c))

# Get polygons for Hartford's bodies of water 
water <- st_intersection(
  st_transform(area_water("CT", "Hartford"), crs = st_crs(hartford_tracts)), 
  hartford_tracts)



```


```{r}
# Rename tract columns to distinguish from parcel and crime data
hartford_tracts <- hartford_tracts %>%
  rename(tract_geometry = geometry, tract_name = NAME, tract_id = GEOID)

# Extract year from crime date
c$year <- year(as.Date(c$Date))

# Join parcel and crime data to census tracts (keep tract geometry)
tp <- st_join(hartford_tracts, p)
tc <- st_join(hartford_tracts, c)

# Extract short tract name from in population data to match tract polygons
pop$tract_name <- gsub("[^0-9.]", "", pop$Census.Tract)

# Calculate average housing price by census tract
ap <- tp %>%
  group_by(tract_name) %>%
  summarise(avg_house_value = mean(Assessed_Total, na.rm = TRUE))

# Calculate crime rate by census tract and year
at <- tc[1:1000,] %>% 
  group_by(tract_name, year) %>%
  summarise(crime_count = n()) %>%
  left_join(pop, by = "tract_name") %>%
  mutate(crime_rate_per_1000 = crime_count / Estimated.Population * 1000) %>%
  select(tract_name, year, crime_rate_per_1000) %>%
  pivot_wider(names_from = year, values_from = crime_rate_per_1000) %>%
  left_join(ap, by = "tract_name") %>%
  select(tract_name, everything()) 

  write.csv(".//data//crime_rate_by_tract.csv", row.names = FALSE)

tc

```



```{r}
# Calculate centroids of parcels and crime
centroids <- st_centroid(p)
coords <- st_coordinates(centroids)
p$centroid.x <- coords[, 'X']
p$centroid.y <- coords[, 'Y']

centroids <- st_centroid(c)
coords <- st_coordinates(centroids)
c$centroid.x <- coords[, 'X']
c$centroid.y <- coords[, 'Y']


# Filter property crimes and violent crimes
stealin <- c[grep("ROBBERY|BURGLARY|LARCENY|THEFT|STOLEN", 
                   c$UCR_1_Category), ]
hurtin <- c[grep("ASSAULT|HOMICIDE|SHOOTING", c$UCR_1_Category), ]

# Get number of thefts and violent crimes within 0.1 miles of each parcel
p$thefts <- sapply(
  st_is_within_distance(p, stealin, dist = units::set_units(0.1, "mi")),  
  length)
p$violence <- sapply(
  st_is_within_distance(p, hurtin, dist = units::set_units(0.1, "mi")), 
  length)

st_within(p$geometry[1], p$geometry[1])
st_within(p$geometry[1], hartford_tracts[1])
```


## Data Exploration

```{r}
# For each census tract, get average property value in 2021 and 
# average annual crime count 
# Create a new dataframe
library(dplyr)
# Add a column for year
c <- c %>%
  mutate(year = year(as.Date(Date)))
# Drop geometry data 
cc <- sf::st_drop_geometry(c)
pp <- sf::st_drop_geometry(p)

# Calculate total crimes per year
crimes_per_year <- table(cc$year)


select(year) %>%
  group_by(year) %>%
  summarise(total_crime_per_yr = n())


# Aggregate crime to census level to get crime rate


```


```{r, warning = FALSE}
# Plot census tracts colored by crime rates and sized by property values
l1 = leaflet(c_tract) %>%
  
  addProviderTiles('CartoDB.Positron') %>%
  
  ## census tracts
  addPolygons(fillColor = ~pal1(rescaled.house.value), 
              label = ~label %>% lapply(htmltools::HTML), 
              weight = 0.5,
              color = 'black',
              fillOpacity = 0.8) %>%
  
  # stops
  addCircleMarkers(data = ds,
                   lng = ~stop1_lon,
                   lat = ~stop1_lat,
                   label = ~label %>% lapply(htmltools::HTML),
                   color = pubred,
                   radius = ~log(`n_to_Grand Central` + `n_to_New Haven`)) %>%
  
  setView(lng = -73.3, 
          lat = 41.21979, 
          zoom = 10) %>%
  
  addTiles()
```


```{r, warning = FALSE}
# Plot sample of crimes and parcels

# library(mapview)
# mapview(dplyr::sample_n(c, 1e3), dplyr::sample_n(p, 1e3))

g <- ggplot(dplyr::sample_n(c, 1e3)) +
   geom_sf(data = hartford_tracts) +
   geom_sf(data = dplyr::sample_n(p, 1e3)) +
   geom_density_2d(aes(X,Y), data = ~cbind(.x, st_coordinates(.x))) +
   stat_sf_coordinates(size = 0.1, color = "red") +
   labs(x = "Latitude", y = "Longitude") +
   theme_bw()

p <- toWebGL(ggplotly(g))
p$x$data[[4]]$hoverinfo <- "none"
p
```

```{r}
# Plot average residential parcel value by census tract 
# with crime counts binned by area

# Map parcel address to 


# Get average residential parcel value by census tract
parcel_dg$Zone

hartford_tracts

parcel_dg$avg_residential_value <- parcel_dg$AV_LAND / parcel_dg$AV_TOTAL
```


## Models

```{r}

```



## References

Spatial regression 

https://oerstatistics.wordpress.com/wp-content/uploads/2016/03/intro_to_r.pdf#page=68.08

https://crd230.github.io/lab8.html

Kernel density estimation

https://seeing-statistics.com/issue4/




## Analysis

### Vanilla OLS regression

For our baseline model, we assume no spatial correlation in the crime and 
property data. 

$$

$$
